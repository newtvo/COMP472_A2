# -*- coding: utf-8 -*-
"""8_Puzzle_A_Star_Algo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V7hnIo6p4XsuxCs4DDx7XYd82zTTtNTd
"""

import copy
#Declare how state looks like
class State:
  def __init__(self, data = None, par = None,
               g = 0, h = 0, op = None):
    self.data = data
    self.par = par
    self.g = g
    self.h = h
    self.op = op
  def clone(self):
    sn = copy.deepcopy(self)
    return sn
  def Print(self):
    # size = 3
    size = 4
    # for i in range(sz):
    for i in range(size-2):
      for j in range(size):
       print(self.data[i*size + j], end = ' ')
      print()
    print()
  def Key(self):
    if self.data == None:
      return None
    res = ''
    for x in self.data:
      res += (str) (x)
    return res
  def __lt__(self, other):
    if other == None:
      return False
    return self.g + self.h < other.g + other.h
  def __eq__(self, other):
    if other == None:
      return False
    return self.Key() == other.Key()

class Operator:
  def __init__(self, i):
    self.i = i
  def check_state_null(self, s):
    return s.data == None
  def find_pos(self, s):
    size = 4
    for i in range(size-2):
      for j in range(size):
        if s.data[i*size + j] == 0:
          return i,j
    return None
  def swap(self, s, x, y, i):
    size = 4
    sn = s.clone()
    x_new = x 
    y_new = y

    #check up-down state
    if i == 0:
      x_new = x + 1
      y_new = y
    if i == 1:
      x_new = x - 1
      y_new = y

    #check left-right state    
    if i == 2:
      x_new = x
      y_new = y + 1
    if i == 3:
      x_new = x
      y_new = y - 1
    sn.data[x * size + y] = sn.data[x_new * size + y_new]
    sn.data[x_new * size + y_new] = 0
    return sn

  def up(self, s):
    if self.check_state_null(s) == True:
      return None
    x, y = self.find_pos(s)
    if x == 1:
      return None
    return self.swap(s, x, y, self.i)

  def down(self, s):
    if self.check_state_null(s) == True:
      return None
    x, y = self.find_pos(s)
    if x == 0:
      return None
    return self.swap(s, x, y, self.i)

  def left(self, s):
    if self.check_state_null(s) == True:
      return None
    x, y = self.find_pos(s)
    if y == 3:
      return None
    return self.swap(s, x, y, self.i)
  
  def right(self, s):
    if self.check_state_null(s) == True:
      return None
    x, y = self.find_pos(s)
    if y == 0:
      return None
    return self.swap(s, x, y, self.i)
  
  def move(self, s):
    if self.i == 0:
      return self.up(s)
    if self.i == 1:
      return self.down(s)
    if self.i == 2:
      return self.left(s)
    if self.i == 3:
      return self.right(s)
    return None

def check_in_pq(Open, tmp):
  if tmp == None:
    return False
  return (tmp in Open.queue)
def equal(O, G):
  if O == None:
    return False
  return O.Key() == G.Key()
def Path(O):
  if O.par != None:
    Path(O.par)
    print(O.op.i)
  O.Print()
def Hx(S, G):
  size = 4
  res = 0
  for i in range(size - 2):
    for j in range(size):
      if S.data[i * size + j] != G.data[i * size + j]:
        res += 1
  return res

from queue import PriorityQueue
def run(S, G):
  Open = PriorityQueue()
  Closed = PriorityQueue()
  S.g = 0
  S.h = Hx(S, G)
  Open.put(S)

  while True:
    if Open.empty() == True:
      print("Search Failed")
      return 
    O = Open.get()
    Closed.put(O)
    if equal(O, G) == True:
      print("Found")
      Path(O)
      return
    #find all children states
    for i in range(4):
      op = Operator(i)
      child = op.move(O)
      if child == None:
        continue
      ok1 = check_in_pq(Open, child)
      ok2 = check_in_pq(Closed, child)

      if not ok1 and not ok2:
        child.par = O
        child.op = op
        child.g = O.g + 1
        child.h = Hx(child, G)
        Open.put(child)

from random import randint
def init(num):
  G = State()
  size = 4
  G.data = []
  for i in range(size-2):
    for j in range(size):
      G.data.append((i * size + j + 1) % 8)
  
  S = G.clone()
  for i in range(num):
    op = Operator(randint(0, 3))
    tmp = op.move(S)
    if tmp != None:
      S = tmp
  return S, G

import time 
t1 = time.time()
S, G = init(50)
S.Print()
G.Print()
run(S, G)
t2 = time.time()
print('time: ', (t2 -1))
